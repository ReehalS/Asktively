(()=>{"use strict";const e=["Multiple Choice","True or False","Fill In the Blanks","Short Answer"],n=['Make four options for each question. Each option should start with the text "OPTION: ". The answer should be the index of the option at which the answer is present. The answer should come after all the options have been listed. Here is a sample output:\nQUESTION 1: This is the first question?\nOPTION: 1. This is the first option.\nOPTION: 2. This is the second option.\nOPTION: 3. This is the third option.\nOPTION: 4. This is the fourth option.\nANSWER: 2','After the "ANSWER: " text, output "TRUE" or "FALSE" in the same line depending on what the answer is. The answer should only be "TRUE" or "FALSE". Do not make answers that are short answer or fill in the blanks questions.',"Leave 3 underscores where the blank portion of the question is. Do not write the answer in the same line as the question.","The minimum answer length should be 20 words and maximum answer length should be 50 words."];chrome.runtime.onInstalled.addListener((async()=>{const{available:s}=await ai.languageModel.capabilities();function t(e,n){const s={"Multiple Choice":[],"True or False":[],"Fill In the Blanks":[],"Short Answer":[]},t=/QUESTION\s*\d+:\s*(.*?)\.?\s*(OPTION:\s*[0-4A-D]\:?[\s]*.*?)(?:\s*(OPTION:\s*[0-4A-D]\:?[\s]*.*?)){3}\s*(ANSWER:\s*[0-4A-D])\.?\s*(?:\n\s*)*/gs,r=/QUESTION\s*\d+:\s*(.*?)\.?\s*ANSWER:\s*(TRUE|FALSE)\.?(\s*(?:\n\s*)*)/gis,o=/QUESTION\s*\d+\s*(?:\n\s*)?:\s*(.*?)\s*(?:\n\s*)?(ANSWER:\s*(.*?))\.?\s*(?:\n\s*)*/gs,a=/QUESTION\s*\d+:\s*(.*?)\.?\s*ANSWER:\s*(.*?)\.?\s*(?:\n\s*)*/gs;if("Multiple Choice"===n){const n=e.matchAll(t);for(const e of n){const n=e[1].trim(),t=e[2].split("OPTION: ").slice(1).map((e=>e.trim())),r=t.findIndex((n=>e[3].includes(n)))+1;s["Multiple Choice"].push({question:n,options:t,answer:r})}}else if("True or False"===n){const n=e.matchAll(r);for(const e of n){const n=e[1].trim(),t="TRUE"===e[2];s["True or False"].push({question:n,answer:t})}}else if("Fill In the Blanks"===n){const n=e.matchAll(o);for(const e of n)s["Fill In the Blanks"].push({question:e[1].trim(),answer:e[2].trim()})}else if("Short Answer"===n){const n=e.matchAll(a);for(const e of n)s["Short Answer"].push({question:e[1].trim(),answer:e[2].trim()})}return s[n]}if("no"!==s)for(let s=0;s<e.length;s++){const r=`Make 10 ${e[s]} type questions. Make each question start with the text "QUESTION" followed by the question number and a colon. The question should be in the same line as "QUESTION" text. Make the Answer for each question start with the text "ANSWER: ". The answer should be in the same line as the "ANSWER: " text. ${n[s]} The answer should come after the question and all the options for that question. Do not output anything except the questions, answers, and options. Always output in English. The content to make questions for starts below:\nECS 150: Operating systems\nProcess APIs\nAdministrative\nLate policy on projects: 2 days (48 hours)\nProject 1 due on Monday\nProject 2 out on Monday, due in two weeks\n(wrapping up last lecture) System call implementation\nProcess APIs to manage processes\nIn class today we’ll go over fork, exec, and wait\nIn discussion on Friday, the TAs will cover pipe, and dup2\nYou’ll use all of these in project 2 when you create your own shell\nKey concepts\n• Processes can create processes, modern computer systems\nhave 100s of processes at any given time\n• Processes have an hierarchy defined by a parent / child\nrelationship between the process that creates a new one and\nthe new process.\n• Processes are (mostly) isolated from one another\n• The OS provides system calls (the Process API) to interact with\nother processes through these well-defined interfaces\nConceptual fork: Processes have a kernel data\nstructure to keep track of metadata for the proc.\nKernel\nUser\nBash\nPID: 123\nParent: 121\nPage table\nfds\n…\nregisters\nIf Bash calls “fork” it creates a new process that\nstarts as a copy of the original process\nKernel\nUser\nBash\nPID: 123\nParent: 121\nPage table\nfds\n…\nregisters\nBash\nPID: 124\nParent: 123\nPage table\nfds\n…\nregisters\nIf the new process calls “exec” it replaces the\nprogram but the process remains the same\nKernel\nUser\nBash\nPID: 123\nParent: 121\nPage table\nfds\n…\nregisters\ndish\nPID: 124\nParent: 123\nPage table\nfds\n…\nregisters\nIf dish calls “fork” it creates another new process\nKernel\nUser\nBash\nPID: 123\nParent: 121\nPage table\nfds\n…\nregisters\ndish\nPID: 124\nParent: 123\nPage table\nfds\n…\nregisters\ndish\nPID: 125\nParent: 124\nPage table\nfds\n…\nregisters\nAnd another (both children)\nKernel\nUser\nBash\nPID: 123\nParent: 121\nPage table\nfds\n…\nregisters\ndish\nPID: 124\nParent: 123\nPage table\nfds\n…\nregisters\ndish\nPID: 125\nParent: 124\nPage table\nfds\n…\nregisters\ndish\nPID: 126\nParent: 124\nPage table\nfds\n…\nregisters\nBefore “exec” replaces the program on one of them\nwith “ls”\nKernel\nUser\nBash\nPID: 123\nParent: 121\nPage table\nfds\n…\nregisters\ndish\nPID: 124\nParent: 123\nPage table\nfds\n…\nregisters\ndish\nPID: 125\nParent: 124\nPage table\nfds\n…\nregisters\nls\nPID: 126\nParent: 124\nPage table\nfds\n…\nregisters\nImportant takeaways\n• Fork creates new processes, which start off as a copy\n• After the fork call, the two processes will deviate and run\nindependently\n• Processes maintain a hierarchy where the process that calls\nfork is the parent of the process that the system creates\n• Exec keeps the same process but replaces the program\nFile descriptors are copied from parent to child, but can reference\nthe same underlying object (e.g., the same file)\nLet’s see it in action!`,o=Date.now(),a=await ai.languageModel.create({systemPrompt:"Pretend to be a professor that is creating a question bank for a class."}),i=Date.now();try{const n=await a.prompt(r),h=Date.now();if(console.log(e[s]),console.log(`sessionCreateTime = ${i-o}. promptTime = ${h-i}`),console.log(n),n.length>0){const r=t(n,e[s]);console.log(r),chrome.runtime.sendMessage({type:e[s],output:r})}}catch(e){console.error("Error fetching from AI model:",e)}}}))})();